# 🚀 快速开始指南

## 已完成的修改

✅ 修改了 `xz_main.c` - 实现WebSocket音频接收和播放  
✅ 创建了 `opus_decoder_wrapper.h` - Opus解码器接口  
✅ 创建了 `opus_decoder_wrapper.c` - Opus解码器实现  
✅ 创建了完整的技术文档

## 核心功能

```
WebSocket接收 → 判断消息类型
    ↓
type=129 (JSON) → 处理控制消息（TTS开始/结束等）
type=130 (二进制) → Opus音频数据 → 解码 → 播放
```

## 立即使用（3步）

### 第1步：集成libopus库

**选择A：使用标准libopus（推荐）**
```c
// 在 opus_decoder_wrapper.c 顶部取消注释：
#define USE_LIBOPUS
```
然后添加libopus的头文件和库文件到项目中。

**选择B：使用SDK内置opus库**
```makefile
# 在Makefile中添加：
LIBS += $(src)/cpu/wl82/liba/lib_opus_dec.a
```

### 第2步：修改Makefile

参考 `Makefile_opus_integration.txt` 添加以下内容：

```makefile
# 添加源文件
objs += \
    websocket/xz_main.o \
    websocket/opus_decoder_wrapper.o

# 添加头文件路径
INCLUDES += \
    -I$(src)/apps/common/audio_music \
    -I$(src)/include_lib/server
```

### 第3步：编译和测试

```bash
make clean
make
# 烧录固件到开发板
# 查看串口输出验证功能
```

## 验证工作正常

串口会输出：
```
✓ Audio player initialized successfully
✓ Opus decoder initialized
✓ Received Opus audio data, len: xxx
✓ Played PCM data: 960 samples, 1920 bytes
```

## 临时测试方案（无需libopus）

如果暂时无法集成opus解码器，可以让服务器直接发送PCM数据：

在 `xz_main.c` 第183行的 `else if (type == 130)` 部分，替换为：
```c
else if (type == 130) {
    // 假设服务器发送的是PCM数据
    if (!g_audio_playing) {
        audio_player_init();
    }
    audio_play_pcm_data(buf, len);  // 直接播放
}
```

## 配置参数

在 `xz_main.c` 中可调整的参数：

```c
#define OPUS_SAMPLE_RATE 16000  // 采样率
#define OPUS_CHANNELS 1         // 声道数
#define OPUS_FRAME_DURATION 60  // 帧时长(ms)

// audio_player_init() 函数中：
80,  // 音量 (0-100)
```

## 常见问题速查

| 问题 | 解决 |
|-----|-----|
| 编译错误: opus_* 未定义 | 添加libopus库文件 |
| 没有声音 | 检查音量设置和DAC配置 |
| 播放卡顿 | 增大 PCM_BUFFER_SIZE |

## 详细文档

📖 **完整技术文档**: `OPUS_AUDIO_PLAYBACK_README.md`  
📖 **中文说明**: `实现说明_简体中文.md`  
📖 **修改总结**: `修改总结.md`  
📖 **Makefile配置**: `Makefile_opus_integration.txt`

## 技术支持

代码中包含详细的注释和调试输出，有问题请查看串口日志。

---
**状态**: ✅ 实现完成  
**版本**: v1.0  
**日期**: 2025-10-30

